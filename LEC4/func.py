
# def f(x):
#     return x**2
 
# g = f                 #создаем переменную типа "функция", переменная хранит в себе функцию

# print(type(f))        #какой тип данных у функции, чем сама по себе является функция
# print(type(g))

# print(f(2))    #2 в квадрате = 4
# print(g(2))    #ответ такой же как в f(2)
#________________________________________________________________________________________

# def calc1(x):
#     return x + 10

# print(calc1(10))

# def calc2(x):
#     return x * 10
# print(calc2(10))

#мы можем взять функцию, которая в место аргумента будет принимать операцию и что-то выдавать

# def math(op, x):
#     print(op(x))

# math(calc2, 10)
# math(calc1, 10)
#теперь не надо каждый раз писать функцию, а можно вызывать ее

#________________________________________________________________________________________
#================LAMBDA============================

# def sum(x, y):
#     return x+y
#f = sum

#sum = lambda x, y: x + y   #фактически тоже самое, что и стр 34-36

# def mylt(x, y):
#     return x*y

# def calc(op, a, b):
#     print(op (a, b))
#     return op(a, b)
    
# #calc(sum, 4, 5)
# #мы можем сразу в код забрасывать lambda:  

# calc(lambda x, y: x + y, 5, 5)
#______________________________________________________________________________________
#============List Comprehension======================================
#чтобы быстро создавать списки

# [exp for item in iterable]
# [exp for item in iterable (if conditional)]
# [exp <if conditional> for item in iterable (if conditional)]

#смотри main.py
#будут перебираться все числа в диапазоне от 1 до 20, из них 
#выбираться четные, после этого  они будут возводится в третью степень

# def f(x):
#     return x**3

# list = [(i, f(i)) for i in range(1, 21) if i % 2 == 0]   #а можно подключить картежи, и будет пара, число и степень
# print(list)